import 'package:ulid/ulid.dart';

/// Status of a stored memory.
enum MemoryStatus {
  /// Active and eligible for recall.
  active,

  /// Replaced by a newer memory (contradiction resolution).
  superseded,

  /// Session-scoped item expired at session boundary or capacity eviction.
  expired,

  /// Importance decayed below floor threshold.
  decayed,
}

/// A consolidated memory in the unified store.
///
/// All memory components (task, durable, environmental) write to the same
/// store using this model. The [component] and [category] fields identify
/// the origin; recall queries the full index regardless of component.
class StoredMemory {
  /// Unique identifier (ULID).
  final String id;

  /// The memory content — a standalone, self-contained statement.
  final String content;

  /// Which component created this memory (e.g., 'task', 'durable',
  /// 'environmental').
  final String component;

  /// Component-specific category (e.g., 'goal', 'fact', 'capability').
  final String category;

  /// Importance score (0.0–1.0). Set by the component at creation.
  final double importance;

  /// Session that produced this memory. Null for cross-session memories
  /// (durable, environmental).
  final String? sessionId;

  /// IDs of source episodes that contributed to this memory.
  final List<String> sourceEpisodeIds;

  /// Embedding vector. Null until generated by the engine post-consolidation.
  final List<double>? embedding;

  /// IDs of entities referenced by this memory.
  final List<String> entityIds;

  /// When this memory was first created.
  final DateTime createdAt;

  /// When this memory was last modified.
  final DateTime updatedAt;

  /// When this memory was last recalled.
  final DateTime? lastAccessed;

  /// Number of times this memory has been recalled.
  final int accessCount;

  /// Current lifecycle status.
  final MemoryStatus status;

  /// When this memory became valid. Null means valid since [createdAt].
  final DateTime? validAt;

  /// When this memory became invalid. Null means still valid.
  final DateTime? invalidAt;

  /// ID of the memory that superseded this one.
  final String? supersededBy;

  StoredMemory({
    String? id,
    required this.content,
    required this.component,
    required this.category,
    this.importance = 0.5,
    this.sessionId,
    this.sourceEpisodeIds = const [],
    this.embedding,
    this.entityIds = const [],
    DateTime? createdAt,
    DateTime? updatedAt,
    this.lastAccessed,
    this.accessCount = 0,
    this.status = MemoryStatus.active,
    this.validAt,
    this.invalidAt,
    this.supersededBy,
  })  : id = id ?? Ulid().toString(),
        createdAt = createdAt ?? DateTime.now().toUtc(),
        updatedAt = updatedAt ?? DateTime.now().toUtc();

  /// Whether this memory is currently active and temporally valid.
  bool get isActive {
    if (status != MemoryStatus.active) return false;
    final now = DateTime.now().toUtc();
    if (validAt != null && now.isBefore(validAt!)) return false;
    if (invalidAt != null && now.isAfter(invalidAt!)) return false;
    return true;
  }
}

/// An entity in the knowledge graph.
class Entity {
  /// Unique identifier (ULID).
  final String id;

  /// The entity name (e.g., 'Dart', 'rabbits').
  final String name;

  /// The entity type (e.g., 'language', 'animal').
  final String type;

  Entity({
    String? id,
    required this.name,
    required this.type,
  }) : id = id ?? Ulid().toString();
}

/// A relationship between two entities.
class Relationship {
  /// Source entity ID.
  final String fromEntity;

  /// Target entity ID.
  final String toEntity;

  /// Relationship type (e.g., 'used_for', 'is_a').
  final String relation;

  /// Confidence score (0.0–1.0).
  final double confidence;

  /// When this relationship was last updated.
  final DateTime updatedAt;

  Relationship({
    required this.fromEntity,
    required this.toEntity,
    required this.relation,
    this.confidence = 1.0,
    DateTime? updatedAt,
  }) : updatedAt = updatedAt ?? DateTime.now().toUtc();
}
